Long has been the time when consensus started to be defined as a fundamental problem of distributed systems [Lamport 3 papers]. Generally, consensus means reaching an agreement between multiple parties in the potential presence of faulty individuals. As per multi-agent systems, interacting over computer networks, "consensus" is thought to be the result of a coordination effort such that those parties agree on some value at a given moment. Achieving consensus implies that the system shall be reliable and fault-tolerant. However, the consensus problem has been limited by some assumptions on the networks. The well-known "secure Byzantine-Fault-Tolerant multiparty consensus systems" that have been designed over the years are usually meant to work only with a set of known participants, faulty or not [PBFT]. The other side of the coin is the permissionless consensus challenge, consisting of achieving agreement in an environment where the participants are unknown and untrusted [Bitcoin, Ethereum]. Plus, there are other intrinsic particularities of this type of networks, like their openness, and the lack of any kind of central authority. This adds another layer of complexity to the problem, as the participants are not only unknown and untrusted but can also join or leave the network at any time, freely choosing if they want to participate in the consensus protocol or not. Nevertheless, the problem of permissionless consensus can still be seen as a special case of the more general consensus and can still be formalized in the same way. In this paper, we will focus on consensus in permissionless systems, especially in the context of blockchain networks. We will reason about its meaningfulness by trying to identify the units that may underpin consensus. We will also discuss the current state-of-the-art, with a particular interest in the shift of the consensus layer of these distributed networks to mobile and edge computing environments, for which computationally expensive consensus algorithms are impractical and unfair.

The establishment of a definition for the problem of reaching agreement in a distributed system was pioneered by L. Lamport in [Reaching Agreement in the Presence of Faults - 1]. He defined consensus as the problem of agreeing on a single value among a set of processes in the presence of faulty entities. The first consensus algorithms were designed for synchronous systems, where the communication between the processes is reliable, and the delay is bounded. However, these initial attempts failed to bind the different types of faulty behaviour. Along with the establishment of the famous Byzantine Generals Problem, the first solutions, not only for dealing with treason, but also for unreliable communication channels between the participants, or any other kind of arbitrary byzantine behaviour, were also proposed by Lamport in [The Byzantine Generals Problem]. The solution was a synchronous mechanism that used a set of leaders to reach consensus. Multiple practical implementations and optimizations to this solution have been proposed in the literature. The first asynchronous consensus algorithm was later proposed by Castro and Liskov in [Practical Byzantine Fault Tolerance]. And naturally after that work, many other asynchronous consensus algorithms have appeared. However, all of them are based on the assumption that the number of faulty processes is less than a certain threshold, which still does not cope with what is generally the majority threshold for true democratic consensus - "a number or percentage equaling more than half of a total" [Dictionary]. Plus, the assumption of a known set of participants is also made. This is a very strong assumption, as it is not always possible to know the participants beforehand. The advancement of the internet more than potentiated the revolution and what we now call the "permissionless" consensus problem was finally born. Without forgetting the previous attempts, the first permissionless consensus algorithm was proposed by Nakamoto in [Bitcoin]. It is a proof-of-work consensus protocol that resembles a "replicated state machine" where the independent participants reach agreement not only about transactional values, but also about their order. "Proof-of-work is essentially one-CPU-one-vote" and this is the novelty introduced by Bitcoin [Bitcoin, Hybrid Consensus: Scalable Permissionless Consensus]. The focus shifted for decentralized systems and after proof-of-work many other consensus mechanisms have been proposed, based on different consensus units, like proof-of-stake, proof-of-space, proof-of-burn, etc. The chaotic diversity of new consensus protocols gave also space for endless reviews, overviews and comparisons [all reviews]. Among those, some focused their efforts on mechanisms that may work in resource-constrained networks [IoT reviews], and this paper will try to identify the common conclusions about the state-of-the-art of running consensus protocols in mobile and edge devices.